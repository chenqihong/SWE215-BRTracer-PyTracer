<?xml version="1.0" encoding="ISO-8859-1"?>
<bugrepository name="LANG">
  <bug id="419" opendate="2008-03-26 17:05:00" fixdate="2008-05-11 05:18:00">
    <buginformation>
      <summary>WordUtils.abbreviate bug when lower is greater than str.length</summary>
      <description>
        In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower.
        But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too...
        Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException

        The fix is to adjust lower to the length of the string
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/WordUtils.java</file>
      <file>src/test/org/apache/commons/lang/WordUtilsTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="393" opendate="2008-01-03 13:46:00" fixdate="2008-01-13 07:00:00">
    <buginformation>
      <summary>EqualsBuilder don't compare BigDecimals correctly</summary>
      <description>
      When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal.
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/builder/EqualsBuilder.java</file>
      <file>src/test/org/apache/commons/lang/builder/EqualsBuilderTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="380" opendate="2007-11-29 16:24:00" fixdate="2007-11-29 16:34:00">
    <buginformation>
      <summary>infinite loop in Fraction.reduce when numerator == 0</summary>
      <description>Summary pretty much says it all.</description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/math/Fraction.java</file>
      <file>src/test/org/apache/commons/lang/math/FractionTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="365" opendate="2007-10-26 18:58:00" fixdate="2007-10-27 05:07:00">
    <buginformation>
      <summary>BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException</summary>
      <description>
        The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test:
        assertEquals(false, BooleanUtils.toBoolean("tru"));
        The end of case 3 should return false.
        Patch to follow for source and unit test.
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/BooleanUtils.java</file>
      <file>src/test/org/apache/commons/lang/BooleanUtilsTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="346" opendate="2007-07-06 20:06:00" fixdate="2007-08-09 00:25:00">
    <buginformation>
      <summary>Dates.round() behaves incorrectly for minutes and seconds</summary>
      <description>
        Get unexpected output for rounding by minutes or seconds.
        public void testRound()
        {
        Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        testCalendar.set(2007, 6, 2, 8, 9, 50);
        Date date = testCalendar.getTime();
        System.out.println("Before round() " + date);
        System.out.println("After round() " + DateUtils.round(date, Calendar.MINUTE));
        }

        --2.1 produces
        Before round() Mon Jul 02 03:09:50 CDT 2007
        After round() Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect

        --2.2 and 2.3 produces
        Before round() Mon Jul 02 03:09:50 CDT 2007
        After round() Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/time/DateUtils.java</file>
      <file>src/test/org/apache/commons/lang/time/DateUtilsTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="328" opendate="2007-04-16 23:11:00" fixdate="2007-05-01 23:50:00">
    <buginformation>
      <summary>LocaleUtils.toLocale() rejects strings with only language+variant</summary>
      <description>
        LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX

        This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale("fr", "", "POSIX").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code.

        Commons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/LocaleUtils.java</file>
      <file>src/test/org/apache/commons/lang/LocaleUtilsTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="315" opendate="2007-02-06 13:52:00" fixdate="2007-02-06 22:49:00">
    <buginformation>
      <summary>StopWatch: suspend() acts as split(), if followed by stop()</summary>
      <description>
        In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:

        StopWatch sw = new StopWatch();

        sw.start();
        Thread.sleep(1000);
        sw.suspend();
        // Time 1 (ok)
        System.out.println(sw.getTime());

        Thread.sleep(2000);
        // Time 1 (again, ok)
        System.out.println(sw.getTime());

        sw.resume();
        Thread.sleep(3000);
        sw.suspend();
        // Time 2 (ok)
        System.out.println(sw.getTime());

        Thread.sleep(4000);
        // Time 2 (again, ok)
        System.out.println(sw.getTime());

        Thread.sleep(5000);
        sw.stop();
        // Time 2 (should be, but is Time 3 => NOT ok)
        System.out.println(sw.getTime());

        suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/time/StopWatch.java</file>
      <file>src/test/org/apache/commons/lang/time/StopWatchTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="300" opendate="2006-12-19 17:47:00" fixdate="2006-12-19 21:50:00">
    <buginformation>
      <summary>NumberUtils.createNumber throws NumberFormatException for one digit long</summary>
      <description>
        NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc...
        It works fine if you try to parse "01l" or "02l". The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/math/NumberUtils.java</file>
      <file>src/test/org/apache/commons/lang/math/NumberUtilsTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="281" opendate="2006-10-05 16:51:00" fixdate="2006-10-07 00:23:00">
    <buginformation>
      <summary>DurationFormatUtils returns wrong result</summary>
      <description>
        DurationFormatUtils returns wrong result. oddly, it is only when Date is set to Dec 31, 2005
        The following code will result in a String of -2 which is way off.
        I've tested against 2.1 and 2.2.
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.MONTH, Calendar.DECEMBER);
        cal.set(Calendar.DAY_OF_MONTH, 31);
        cal.set(Calendar.YEAR, 2005);
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");
        System.out.println(result);
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/time/DurationFormatUtils.java</file>
      <file>src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java</file>
    </fixedFiles>
  </bug>


  <bug id="259" opendate="2006-05-22 21:10:00" fixdate="2006-08-18 22:21:00">
    <buginformation>
      <summary>ValuedEnum.compareTo(Object other) not typesafe - it easily could be...</summary>
      <description>
        int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)
        is not typesafe - if the int-values are the same, it will return "0" even for two totally different sub-classes of ValuedEnum
      </description>
    </buginformation>
    <fixedFiles>
      <file>src/java/org/apache/commons/lang/enums/ValuedEnum.java</file>
      <file>src/test/org/apache/commons/lang/enums/ValuedEnumTest.java</file>
    </fixedFiles>
  </bug>
</bugrepository>
