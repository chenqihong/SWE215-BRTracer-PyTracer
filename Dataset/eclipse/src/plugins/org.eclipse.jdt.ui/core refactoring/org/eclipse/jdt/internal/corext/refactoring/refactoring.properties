###############################################################################
# Copyright (c) 2000, 2005 IBM Corporation and others.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     IBM Corporation - initial API and implementation
###############################################################################
# NLS properties for the Refactoring Core

#######################################
# org.eclipse.jdt.internal.core.refactoring

Assert_assertion_failed=assertion failed;
Assert_null_argument=null argument;

DynamicValidationStateChange_workspace_changed=The workspace has changed since the modification has been created

Checks_Choose_name=Choose a name.
Checks_all_excluded=All resources have been excluded from refactoring. Cannot proceed
Checks_cannot_be_parsed=''{0}'' has syntax errors. Content of that file will not be updated.
Checks_cu_not_created=Compilation unit could not be created for this element.
Checks_cu_not_parsed=This refactoring cannot be performed correctly due to syntax errors in the compilation unit. To perform this operation you will need to fix the errors.
Checks_cu_has_compile_errors=Code modification may not be accurate as affected resource ''{0}'' has compile errors.
Checks_no_dot=Type name cannot contain a dot (.).
Checks_cu_name_used=Compilation unit ''{0}.java'' already exists
Checks_method_native=Method {0}::{1} is native. Running the modified program will cause {2}.
Checks_methodName_constructor=New method name has constructor name.
Checks_methodName_exists=Method ''{0}'' already exists in type ''{1}''.
Checks_methodName_overrides=New method ''{0}'' overrides an existing method in type ''{1}''.
Checks_methodName_returnTypeClash=New method ''{0}'' overrides a method declared in type ''{1}'' that uses a different return type.
Checks_has_main=Type {0} contains a main method - some applications (such as scripts) may not work after refactoring.
Checks_constructor_name=If you proceed, the method ''{0}'' in ''{1}'' will have a constructor name.
Checks_method_names_lowercase=This name is discouraged. According to convention, names of methods should start with a lowercase letter.
Checks_validateEdit= Team provider refused file modification.

#######################################
# org.eclipse.jdt.internal.core.refactoring.base
#######################################

Change_is_unsaved={0} is unsaved.
Change_is_read_only={0} is read only.
Change_has_modifications={0} has been modified since the refactoring got executed.
Change_does_not_exist=''{0}'' does not exist anymore.
Change_same_read_only= The read only state of {0} has changed.
Change_javaChanges= Java Model modifications

UndoCompilationUnitChange_no_resource= Compilation unit ''{0}'' does not have an underlying file.

Refactoring_binary={0} is binary
Refactoring_not_in_model={0} does not exist in the model
Refactoring_read_only={0} is read only
Refactoring_unknown_structure={0} - unknown structure

#######################################
# org.eclipse.jdt.internal.core.refactoring.changes
#######################################
AbstractRenameChange_Renaming=Renaming...

RenameResourceChange_rename_resource=rename resource
RenameResourceChange_name=Rename ''{0}'' to: ''{1}''
RenameResourceChange_does_not_exist=''{0}'' does not exist

DeleteFromClassPathChange_remove=Remove entry from classpath of Java project:

MovePackageChange_move=Move package ''{0}'' to ''{1}''
MoveResourceChange_move=Move resource ''{0}'' to ''{1}''

RenameJavaProjectChange_rename=Rename Java Project ''{0}'' to ''{1}''
RenameJavaProjectChange_update=Updating classpaths

RenameSourceFolderChange_rename=Rename Source Folder ''{0}'' to ''{1}''
RenameSourceFolderChange_rename_archive=Cannot rename archive {0}
RenameSourceFolderChange_rename_external=Cannot rename external archive {0}
RenameSourceFolderChange_rename_linked=Cannot rename linked source folder {0}

AbstractDeleteChange_deleting=deleting

CreatePackageChange_Creating_package=Creating package
CreatePackageChange_Create_package=Create package

AddToClasspathChange_add=Add entry to classpath of Java project:

CopyCompilationUnitChange_copy=Copy ''{0}'' to ''{1}''

CopyPackageChange_copy=Copy package ''{0}'' to ''{1}''

RenamePackageChange_checking_change=Checking change for: {0}
RenamePackageChange_name=Rename package ''{0}'' to ''{1}''

MoveCompilationUnitChange_default_package=(default package)
MoveCompilationUnitChange_name=Move Compilation Unit ''{0}'' to ''{1}''

RenameCompilationUnitChange_name=Rename compilation unit ''{0}'' to ''{1}''

#######################################
# org.eclipse.jdt.internal.core.refactoring.code
#######################################

#-- Extract Method -------------------------------------------
LocalTypeAnalyzer_local_type_from_outside=Selected block references a local type declared outside the selection.
LocalTypeAnalyzer_local_type_referenced_outside=A local type declared in the selected block is referenced outside the selection.

FlowAnalyzer_execution_flow=Selected statements contain a return statement but not all possible execution flows end in a return.

ExtractMethodAnalyzer_assignments_to_local=Ambiguous return value: selected block contains more than one assignment to local variable.
ExtractMethodAnalyzer_only_method_body=Cannot extract new method from selection. Only statements from a method body can be extracted.
ExtractMethodAnalyzer_after_do_keyword=Selection may not start immediately after the \'do\' keyword.
ExtractMethodAnalyzer_super_or_this=Cannot extract super or this call from constructor.
ExtractMethodAnalyzer_cannot_determine_return_type=Cannot determine expression's return type. Using void instead.
ExtractMethodAnalyzer_branch_mismatch=Selection contains branch statement but corresponding branch target is not selected.
ExtractMethodAnalyzer_parent_mismatch=Not all selected statements are enclosed by the same parent statement.
ExtractMethodAnalyzer_cannot_extract_anonymous_type=Cannot extract the body of a anonymous type declaration. Select whole declaration.
ExtractMethodAnalyzer_cannot_extract_variable_declaration_fragment=Cannot extract a variable declaration fragment. Select whole declaration statement.
ExtractMethodAnalyzer_cannot_extract_for_initializer=Cannot extract initialization part of a \'for\' statement.
ExtractMethodAnalyzer_cannot_extract_for_updater=Cannot extract increment part of a \'for\' statement.
ExtractMethodAnalyzer_cannot_extract_variable_declaration=Cannot extract parts of a variable declaration. Select whole declaration.
ExtractMethodAnalyzer_cannot_extract_type_reference=Cannot extract a single type reference.
ExtractMethodAnalyzer_cannot_extract_switch_case=Cannot extract the expression of a case statement.
ExtractMethodAnalyzer_cannot_extract_method_name_reference=Cannot extract a single method name.
ExtractMethodAnalyzer_cannot_extract_name_in_declaration=Cannot extract the name part of a declaration.
ExtractMethodAnalyzer_ambiguous_return_value=Ambiguous return value: expression, access to local or return statement extracted.
ExtractMethodAnalyzer_compile_errors=The method''s body cannot be analyzed because of compilation errors in method ''{0}''. To perform the operation you will need to fix the errors.
ExtractMethodAnalyzer_leftHandSideOfAssignment=Cannot extract the left-hand side of an assignment.
ExtractMethodAnalyzer_single_expression_or_set=Can only extract a single expression or a set of statements.
ExtractMethodAnalyzer_cannot_extract_null_type=Cannot extract null expression.

ExtractMethodRefactoring_name=Extract Method {0} in {1}
ExtractMethodRefactoring_add_method=add new method {0}
ExtractMethodRefactoring_checking_new_name=Checking new method name
ExtractMethodRefactoring_no_set_of_statements=Selection does not mark a set of statements. Only statements from a method body can be extracted.
ExtractMethodRefactoring_substitute_with_call=substitute statement(s) with call to {0}
ExtractMethodRefactoring_change_name=extract method {0} from method {1}
ExtractMethodRefactoring_organize_imports=Organize Imports
ExtractMethodRefactoring_duplicates_single=replace duplicate code fragment with call to {0}
ExtractMethodRefactoring_duplicates_multi=replace duplicate code fragments with call to {0}
ExtractMethodRefactoring_error_nameInUse=''{0}'' is already used as a name in the selected code
ExtractMethodRefactoring_error_sameParameter=A parameter ''{0}'' already exists
ExtractMethodRefactoring_error_vararg_ordering=The variable arity parameter ''{0}'' cannot be followed by another parameter

#-- Inline Method ------------------------------------------------------
InlineMethodRefactoring_name= Inline Method Refactoring
InlineMethodRefactoring_searching= Searching for references...
InlineMethodRefactoring_processing= Processing {0}
InlineMethodRefactoring_edit_inline= Inline invocation
InlineMethodRefactoring_edit_delete= Delete method declaration
InlineMethodRefactoring_edit_inlineCall= Inline Call
InlineMethodRefactoring_edit_import= Update import statements
InlineMethodRefactoring_error_classFile=Cannot inline method ''{0}'' since it is declared in a class file.
InlineMethodRefactoring_nestedInvocation=Nested invocation. Only the innermost invocation will be inlined.
InlineMethodRefactoring_error_noMethodDeclaration= Unable to resolve corresponding method declaration.
InlineMethodRefactoring_checking_overridden= Checking for overridden methods...

# The three keys below are referenced indirectly by passing a string to a helper
# method. Do not remove them even if they are marked as unused.
InlineMethodRefactoring_checking_overridden_error= Type {0} overrides method to be inlined.
InlineMethodRefactoring_checking_overrides_error= Method to be inlined overrides method from class {0}.
InlineMethodRefactoring_checking_implements_error= Method to be inlined implements method from interface {0}.
# End of do-not-remove section.

InlineMethodRefactoring_SourceAnalyzer_recursive_call=Method declaration contains recursive call.
InlineMethodRefactoring_SourceAnalyzer_declaration_has_errors=The method declaration contains compile errors. To perform the operation you will need to fix the errors.
InlineMethodRefactoring_SourceAnalyzer_typedeclaration_has_errors=The type declaration contains compile errors. To perform the operation you will need to fix the errors.

InlineMethodRefactoring_SourceAnalyzer_qualified_this_expressions=Cannot inline a method that uses qualified this expressions.
InlineMethodRefactoring_SourceAnalyzer_syntax_errors=The compilation unit containing this method declaration has syntax errors. To perform the operation you will need to fix the errors.
InlineMethodRefactoring_SourceAnalyzer_abstract_methods=Cannot inline abstract methods.

CallInliner_receiver_type=Cannot determine receiver\'s type.
CallInliner_execution_flow=Cannot inline method. Return statement in method declaration interrupts execution flow.
CallInliner_multiDeclaration=Cannot inline method used as an initializer in a multi fragment variable declaration.
CallInliner_simple_functions=Inlining is only possible on simple functions (consisting of a single return statement), or functions used in an assignment.
CallInliner_field_initializer_simple=In field initializers inlining is only supported for simple functions (e.g. functions consisting of a single return statement).
CallInliner_field_initialize_new_local=Cannot inline field initializer because new local variable is required.
CallInliner_field_initialize_write_parameter=Cannot inline field initializer because one of the method parameters is used as an assignment target and will require new local variable.
CallInliner_field_initialize_self_reference=Cannot inline method. Method references the field to be initialized.
CallInliner_constructors=Cannot inline a constructor invocation that is used as a class instance creation.
CallInliner_cast_analysis_error=Cannot analyze call context to determine if implicit cast is needed.

TargetProvider_inaccurate_match=Inaccurate references to method found. References will be ignored.
TargetProvider_method_declaration_not_unique=Cannot uniquely resolve method to be inlined.


#-- SEF ------------------------------------------------------
SelfEncapsulateField_AccessAnalyzer_encapsulate_read_access=Encapsulate read access
SelfEncapsulateField_AccessAnalyzer_encapsulate_write_access=Encapsulate write access
SelfEncapsulateField_AccessAnalyzer_encapsulate_prefix_access=Encapsulate prefix access
SelfEncapsulateField_AccessAnalyzer_encapsulate_postfix_access=Encapsulate postfix access
SelfEncapsulateField_AccessAnalyzer_cannot_convert_postfix_expression=Cannot convert postfix expression. It is used inside another expression.

SelfEncapsulateField_name=Self Encapsulate Field
SelfEncapsulateField_method_exists=A method ''{0}'' already exists in type ''{1}''.
SelfEncapsulateField_compiler_errors_field=Cannot analyze field ''{0}'' due to the following compiler error: {1}
SelfEncapsulateField_compiler_errors_update={0} contains compiler errors. This may affect field access update.
SelfEncapsulateField_type_not_resolveable=The type of the selected field cannot be resolved. An import statement may be missing.
SelfEncapsulateField_cannot_analyze_selected_field=Cannot analyze selected field ''{0}''
SelfEncapsulateField_checking_preconditions=Checking preconditions..
SelfEncapsulateField_searching_for_cunits=Searching for affected compilation units...
SelfEncapsulateField_analyzing=Analyzing...
SelfEncapsulateField_create_changes=Create changes
SelfEncapsulateField_change_visibility=Change visibility to private
SelfEncapsulateField_add_setter=Add Setter method
SelfEncapsulateField_add_getter=Add Getter method

#-- inline temp ------------------------------------------------------
InlineTempRefactoring_name=Inline local variable
InlineTempRefactoring_syntax_errors=This compilation unit contains syntax errors. To perform the operation you will need to fix the errors.
InlineTempRefactoring_select_temp=A local variable declaration or reference must be selected to activate this refactoring.
InlineTempRefactoring_method_parameter=Cannot inline method parameters.
InlineTempRefactoring_exceptions_declared=Cannot inline exceptions declared in \'catch\' clauses.
InlineTempRefactoring_not_initialized=Local variable ''{0}'' is not initialized at declaration.
InlineTempRefactoring_assigned_more_once=Local variable ''{0}'' is assigned more than once.
InlineTempRefactoring_preview=Checking preconditions...
InlineTempRefactoring_inline=Inline local variable
InlineTempRefactoring_inline_edit_name=Replace variable reference with expression
InlineTempRefactoring_remove_edit_name=Remove variable declaration
InlineTempRefactoring_Array_vars_initialized=Array variables initialized with constants cannot be inlined.
InlineTempRefactoring_for_initializers=Cannot inline variables declared in the initializer list of a \'for\' statement.

#-- extract temp ------------------------------------------------------
ExtractTempRefactoring_name=Extract Local Variable
ExtractTempRefactoring_select_expression=An expression must be selected to activate this refactoring.
ExtractTempRefactoring_syntax_error=This file contains syntax errors. To perform this operation you will need to fix the errors.
ExtractTempRefactoring_explicit_constructor=Code from explicit constructor calls cannot be extracted to a variable.
ExtractTempRefactoring_expr_in_method_or_initializer=An expression used in a method or in an initializer must be selected to activate this refactoring.
ExtractTempRefactoring_no_void=Cannot extract an expression of type \'void\'.
ExtractTempRefactoring_null_literals=Cannot extract single null literals.
ExtractTempRefactoring_array_initializer=Operation not applicable to an array initializer.
ExtractTempRefactoring_another_variable=A variable with name ''{0}'' is already defined in the visible scope.
ExtractTempRefactoring_assignment=Cannot extract assignment that is part of another expression.
ExtractTempRefactoring_single_conditional_expression=Currently no support to extract a single conditional expression.
ExtractTempRefactoring_convention=This name is discouraged. According to convention, names of local variables should start with a lowercase letter.
ExtractTempRefactoring_checking_preconditions=Checking preconditions...
ExtractTempRefactoring_preview=Checking preconditions...
ExtractTempRefactoring_extract_temp=Extract Temp
ExtractTempRefactoring_update_imports=Update imports
ExtractTempRefactoring_declare_local_variable=Add variable declaration
ExtractTempRefactoring_replace=Replace expression with variable reference
ExtractTempRefactoring_name_in_new=Cannot extract this name - try selecting the whole instance creation expression.
ExtractTempRefactoring_names_in_declarations=An expression has to be selected to activate this refactoring. Names used in declarations are not expressions.
ExtractTempRefactoring_assigned_to=The selected expression is assigned. Extracting may change the program\'s semantics.
ExtractTempRefactoring_refers_to_for_variable=Cannot extract expression, since it refers to a variable declared in the initializer of the enclosing \'for\' statement.
ExtractTempRefactoring_for_initializer_updater=Cannot extract \'for\' initializer or updater.

#-- extract constant --------------------------------------------------
ExtractConstantRefactoring_name=Extract Constant
ExtractConstantRefactoring_select_expression=An expression must be selected to activate this refactoring.
ExtractConstantRefactoring_syntax_error=This file contains syntax errors. To perform this operation you will need to fix the errors.
ExtractConstantRefactoring_declare_constant=Add constant declaration
ExtractConstantRefactoring_replace=Replace expression with constant reference
ExtractConstantRefactoring_another_variable=A variable with name ''{0}'' is already defined in the visible scope.
ExtractConstantRefactoring_no_void=Cannot extract an expression of type \'void\'.
ExtractConstantRefactoring_null_literals=Cannot extract single null literals.
ExtractConstantRefactoring_not_load_time_constant=Cannot extract this expression - it is not a valid static constant.
ExtractConstantRefactoring_convention=This name is discouraged. According to convention, names of class constants do not contain lowercase letters.
ExtractConstantRefactoring_checking_preconditions=Checking preconditions...

#-- introduce parameter --------------------------------------------------
IntroduceParameterRefactoring_name=Introduce Parameter
IntroduceParameterRefactoring_syntax_error=This compilation unit contains syntax errors. To perform the operation you will need to fix the errors.
IntroduceParameterRefactoring_select=An expression must be selected to activate this refactoring.
IntroduceParameterRefactoring_expression_in_method=An expression used in a method must be selected to activate this refactoring.
IntroduceParameterRefactoring_cannot_introduce=Cannot introduce parameter: {0}.
IntroduceParameterRefactoring_no_binding=Cannot resolve binding of enclosing method declaration.
IntroduceParameterRefactoring_no_void=Cannot introduce a parameter from an expression of type \'void\'.
IntroduceParameterRefactoring_replace=Replace expression with a parameter reference

#######################################
# org.eclipse.jdt.internal.core.refactoring.rename
#######################################
RenameCompilationUnitRefactoring_name=Rename ''{0}'' to ''{1}''
RenameCompilationUnitRefactoring_not_parsed={0} has syntax errors. No references will be updated if you proceed
RenameCompilationUnitRefactoring_not_parsed_1={0} has syntax errors.
RenameCompilationUnitRefactoring_same_name=The name has not been changed.

RenameEnumConstRefactoring_name=Rename enum constant ''{0}'' to ''{1}''
RenameEnumConstRefactoring_convention=This name is discouraged. According to convention, names of enum constants do not contain lowercase letters.
RenameEnumConstRefactoring_another_name=Choose another name.
RenameEnumConstRefactoring_const_already_defined=Enum constant with this name is already defined.

RenameFieldRefactoring_name=Rename field ''{0}'' to ''{1}''
RenameFieldRefactoring_searching=Searching for references...
RenameFieldRefactoring_checking=Checking preconditions...
RenameFieldRefactoring_hiding=After renaming, the field ''{0}'' will be hidden in the scope of the field ''{1}'' declared in type ''{2}''
RenameFieldRefactoring_hiding2=After renaming, the field named ''{0}'' declared in type ''{1}'' will be hidden in the scope of the field ''{2}''
RenameFieldRefactoring_another_name=Choose another name.
RenameFieldRefactoring_field_already_defined=Field with this name is already defined.
RenameFieldRefactoring_deleted=The selected field has been deleted from ''{0}''
RenameFieldRefactoring_already_exists=Method ''{0}'' already exists in ''{1}''
RenameFieldRefactoring_overridden=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring_overridden_or_overrides=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring_Update_getter_occurrence=Update getter occurrence
RenameFieldRefactoring_Update_setter_occurrence=Update setter occurrence
RenameFieldRefactoring_Update_field_declaration=Update field declaration
RenameFieldRefactoring_Update_field_reference=Update field reference
RenameFieldRefactoring_should_start_lowercase=This name is discouraged. According to convention, field names should start with a lowercase letter.
RenameFieldRefactoring_declared_in_supertype=Cannot be renamed because it is declared in a supertype

RenameTypeParameterRefactoring_deleted=The selected type variable has been deleted from ''{0}''
RenameTypeParameterProcessor_name=Rename type variable ''{0}'' to ''{1}''
RenameTypeParameterRefactoring_should_start_lowercase=This name is discouraged. According to convention, names of type variables do not contain lowercase letters.
RenameTypeParameterRefactoring_another_name=Choose another name.
RenameTypeParameterRefactoring_method_type_parameter_already_defined=A type variable with this name is already defined in the declaring method.
RenameTypeParameterRefactoring_class_type_parameter_already_defined=A type variable with this name is already defined in the declaring type.
RenameTypeParameterRefactoring_searching=Searching for references...
RenameTypeParameterRefactoring_checking=Checking preconditions...
RenameTypeParameterRefactoring_update_type_parameter_declaration=Update type variable declaration
RenameTypeParameterRefactoring_update_type_parameter_reference=Update type variable reference
RenameTypeParameterRefactoring_type_parameter_inner_class_clash=The new type variable name conflicts with the name of the inner class ''{0}''.

RenamePackageRefactoring_another_name=Choose another name.
RenamePackageRefactoring_checking=Checking preconditions...
RenamePackageRefactoring_creating_change=Preparing preview...
RenamePackageRefactoring_package_exists=Package already exists
RenamePackageRefactoring_searching=Searching for references...
RenamePackageRefactoring_update_reference=Update package reference
RenamePackageRefactoring_update_imports=Update imports
RenamePackageRefactoring_name=Rename package ''{0}'' to ''{1}''
RenamePackageRefactoring_aleady_exists=Package ''{0}'' already exists in this project in folder ''{1}''

RenameMethodInInterfaceRefactoring_already_defined=A related type declares a method with the new name (and same number of parameters)
RenameMethodInInterfaceRefactoring_special_case=Cannot rename this method because it is a special case (see the language specification section 9.2 for details)

RenameMethodRefactoring_name=Rename method ''{0}'' to ''{1}''
RenameMethodRefactoring_no_binary=Related method ''{0}'' (declared in ''{1}'') is binary. Refactoring cannot be performed.
RenameMethodRefactoring_no_native=Renaming native methods will cause an unsatisfied link error on runtime.
RenameMethodRefactoring_no_native_1=Related method ''{0}'' (declared in ''{1}'') is native. Renaming will cause an UnsatisfiedLinkError on runtime.
RenameMethodRefactoring_no_read_only=Related method ''{0}'' (declared in ''{1}'') is read-only. Refactoring cannot be performed.
RenameMethodRefactoring_not_in_model=Related method ''{0}'' (declared in ''{1}'') does not exist in the model.
RenameMethodRefactoring_same_name=This name already exists.

RenamePrivateMethodRefactoring_hierarchy_defines=''{0}'' or a type in its hierarchy defines a method ''{1}'' with the same number of parameters and the same parameter type names.
RenamePrivateMethodRefactoring_hierarchy_defines2=''{0}'' or a type in its hierarchy defines a method ''{1}'' with the same number of parameters, but different parameter type names.
RenamePrivateMethodRefactoring_update=Update method reference

RenameVirtualMethodRefactoring_requieres_renaming_native=Renaming ''{0}'' requires renaming a native method. Renaming will cause {1} on runtime.
RenameVirtualMethodRefactoring_hierarchy_declares1=Hierarchy declares a method ''{0}'' with the same number of parameters, but different parameter type names.
RenameVirtualMethodRefactoring_hierarchy_declares2=Hierarchy declares a method ''{0}'' with the same number of parameters and the same parameter type names.

RenameMethodRefactoring_update_occurrence=Update method occurrence
RenameMethodRefactoring_update_declaration=Update method declaration
RenameMethodRefactoring_deleted=The selected method has been deleted from ''{0}''
RenameMethodProcessor_is_binary=Method to be renamed is binary.

RenameTypeRefactoring_checking=Checking preconditions...
RenameTypeRefactoring_choose_another_name=Please choose another name.
RenameTypeRefactoring_creating_change=Preparing preview...
RenameTypeRefactoring_rename_constructor=rename constructor
RenameTypeRefactoring_searching=Searching for references...
RenameTypeRefactoring_update_reference=update type reference
RenameTypeRefactoring_name=Rename type ''{0}'' to ''{1}''
RenameTypeRefactoring_enclosed=Type ''{0}'' is enclosed in a type named ''{1}''
RenameTypeRefactoring_encloses=Type ''{0}'' encloses a type named ''{1}''
RenameTypeRefactoring_exists=Type named ''{0}'' already exists in package ''{1}''
RenameTypeRefactoring_imported=Type named ''{0}'' is imported (single-type-import) in ''{1}'' (a compilation unit must not import and declare a type with the same name)
RenameTypeRefactoring_member_type_exists=Another member type named ''{0}'' already exists in ''{1}''
RenameTypeRefactoring_enclosed_type_native=A type enclosed in type ''{0}'' declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring_name_conflict1=Name conflict with type ''{0}'' in ''{1}''
RenameTypeRefactoring_searching_text=searching for text matches
RenameTypeRefactoring_update=Type declaration update
RenameTypeRefactoring_does_not_exist=Type ''{0}'' does not exist in the saved version of ''{1}''
RenameTypeRefactoring_will_not_rename=Compilation unit will not be renamed
RenameTypeRefactoring_local_type=Local Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring_member_type=Member Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring_another_type=Another type named ''{0} is referenced in ''{1}''

TextMatchUpdater_update=Update textual match
TextMatchUpdater_searching=searching for text matches in:

RippleMethodFinder_analizing_hierarchy=analyzing hierarchy

RefactoringAnalyzeUtil_name_collision=Name collision with name ''{0}''

RefactoringSearchEngine_binary_match_ungrouped=An occurrence in a binary type in project ''{0}'' has been found. These occurrences will not be updated, which may lead to compile errors if you proceed.
RefactoringSearchEngine_binary_match_grouped=Occurrences in binary types in project ''{0}'' have been found. These occurrences will not be updated, which may lead to compile errors if you proceed.
RefactoringSearchEngine_inaccurate_match=Inaccurate matches have been found in resource ''{0}''. Please review changes on the preview page.
RefactoringSearchEngine_searching_occurrences=Searching for occurrences...
RefactoringSearchEngine_searching_referenced_types=Searching for referenced types...
RefactoringSearchEngine_searching_referenced_fields=Searching for referenced fields...
RefactoringSearchEngine_searching_referenced_methods=Searching for referenced methods...

RefactoringSearchEngine_potential_matches=Found potential matches. Please review changes on the preview page.
RefactoringSearchEngine_non_cu_matches=Found matches in binary types. Occurrences will not be updated, which may lead to compile errors if you proceed.

RenameTempRefactoring_must_select_local=A local variable declaration or reference must be selected to activate this refactoring
RenameTempRefactoring_only_in_methods_and_initializers=Only local variables declared in methods and initializers can be renamed
RenameTempRefactoring_lowercase=This name is discouraged. According to convention, names of local variables should start with a lowercase letter.
RenameTempRefactoring_rename=Rename Local Variable
RenameTempRefactoring_changeName=Rename local variable:''{0}'' to: ''{1}''

MethodChecks_overrides=The selected method overrides method ''{0}'' declared in type ''{1}''.
MethodChecks_implements=The selected method is an implementation of method ''{0}'' declared in type ''{1}''

RenameJavaProjectRefactoring_rename=Rename Java project ''{0}'' to:''{1}''
RenameJavaProjectRefactoring_already_exists=A project with that name already exists
RenameJavaProjectRefactoring_read_only=Project ''{0}'' is marked as read-only

RenamePackageRefactoring_searching_text=searching for text matches
RenamePackageRefactoring_Packagered_only=Package ''{0}'' is read-only.
RenamePackageRefactoring_resource_read_only=Resource corresponding to package ''{0}'' is read-only. Click ''Continue'' if still you want to rename it.
RenamePackageRefactoring_contains_type=Package ''{0}'' already contains a type named ''{1}''

RenameResourceRefactoring_Internal_Error=Internal Error
RenameResourceRefactoring_alread_exists=A file or folder with this name already exists
RenameResourceRefactoring_invalidName=This is an invalid name for a file or folder

RenameSourceFolderRefactoring_blank=Name must not start or end with a blank
RenameSourceFolderRefactoring_invalid_name=This is an invalid name for a file or folder
RenameSourceFolderRefactoring_already_exists=An element with this name already exists
RenameSourceFolderRefactoring_alread_exists=An element with this name already exists
RenameSourceFolderRefactoring_rename=Rename Source Folder ''{0}'' to ''{1}''

################ Rename Processors #########################################

RenameResourceProcessor_name=Rename resource ''{0}'' to ''{1}''

#######################################
# org.eclipse.jdt.internal.core.refactoring.reorg
#######################################
MoveRefactoring_reorganize_elements=Reorganize elements

DeleteRefactoring_delete_package_fragment_root= Deleting a package fragment root

MoveCuUpdateCreator_update_imports=update imports
MoveCuUpdateCreator_searching=Searching for references to types in ''{0}''
MoveCuUpdateCreator_update_references=update references

CopyRefactoring_cu_copyOf1=CopyOf{0}
CopyRefactoring_cu_copyOfMore=Copy_{0}_of_{1}
CopyRefactoring_resource_copyOf1=Copy of {0}
CopyRefactoring_resource_copyOfMore=Copy ({0}) of {1}
CopyRefactoring_package_copyOf1={0}.copy
CopyRefactoring_package_copyOfMore={1}.copy{0}

#######################################
# org.eclipse.jdt.internal.core.refactoring.structure
#######################################
PullUpRefactoring_Pull_Up=Pull Up
PullUpRefactoring_no_java_lang_Object=Pull up is not allowed on elements declared in 'java.lang.Object'.
PullUpRefactoring_not_this_type=Pull Up is not allowed on type ''{0}'', since it does not have superclasses to which members could be pulled up.
PullUPRefactoring_no_all_binary=Pull up is not allowed on this type. All super class types are binary.
PullUPRefactoring_not_java_lang_object=Pull up is not allowed on this type. Type has no super types.
PullUpRefactoring_final_fields=Pulling up final fields will result in compilation errors if they are not initialized on creation or in constructors
PullUpRefactoring_checking_referenced_elements=Checking referenced elements...
PullUpRefactoring_type_not_accessible=Type ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring_field_not_accessible=Field ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring_method_not_accessible=Method ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring_different_method_return_type=Method ''{0}'' declared in type''{1}'' has a different return type than its pulled up counterpart, which will result in compile errors if you proceed
PullUpRefactoring_different_field_type=Field ''{0}'' declared in type ''{1}'' has a different type than its pulled up counterpart
PullUpRefactoring_lower_default_visibility=Method ''{0}'' declared in type ''{1}'' has visibility lower than ''default'', which will result in compile errors if you proceed
PullUpRefactoring_lower_protected_visibility=Method ''{0}'' declared in type ''{1}'' has visibility lower than ''protected'', which will result in compile errors if you proceed
PullUpRefactoring_checking=Checking preconditions...
PullUpRefactoring_add_method_stub=Add method stub
PullUpRefactoring_add_abstract_method=Add abstract method declaration
PullUpRefactoring_make_target_abstract=Make destination class abstract
PullUpRefactoring_calculating_required=Calculating required members...
PullUpRefactoring_Field_declared_in_class=Field ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.
PullUpRefactoring_Method_declared_in_class=Method ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.
PullUpRefactoring_field_cannot_be_accessed=Field ''{0}'' cannot be accessed from ''{1}''
PullUpRefactoring_method_cannot_be_accessed=Method ''{0}'' cannot be accessed from ''{1}''
PullUpRefactoring_Type_declared_in_class=Type ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.
PullUpRefactoring_Type_variable_not_available=The type parameter ''{0}'' cannot be mapped to the super type ''{1}''
PullUpRefactoring_Type_variable2_not_available=The type parameters ''{0}'' and ''{1}'' cannot be mapped to the super type ''{2}''
PullUpRefactoring_Type_variable3_not_available=The type parameters ''{0}'', ''{1}'' and ''{2}'' cannot be mapped to the super type ''{3}''
PullUpRefactoring_Type_variables_not_available=Several type parameters cannot be mapped to the super type ''{0}''

MemberCheckUtil_signature_exists=Method ''{0}'' (with the same signature) already exists in type ''{1}'', which will result in compile errors if you proceed
MemberCheckUtil_same_param_count=Method ''{0}'' (with the same number of parameters) already exists in type ''{1}''
MemberCheckUtil_field_exists=Field ''{0}'' already exists in type ''{1}'', which will result in compile errors if you proceed
MemberCheckUtil_type_name_conflict0=Nested type ''{0}'' already exists in type ''{1}'', which will result in compile errors if you proceed
MemberCheckUtil_type_name_conflict1=Destination type has the same simple name as ''{0}'', which will result in compile errors if you proceed
MemberCheckUtil_type_name_conflict2=Destination type is enclosed in a type that has the same simple name as ''{0}'', which will result in compile errors if you proceed
MemberCheckUtil_type_name_conflict3=Destination type has the same simple name as ''{0}'' (enclosed in ''{1}''), which will result in compile errors if you proceed
MemberCheckUtil_type_name_conflict4=Destination type is enclosed in a type that has the same simple name as ''{0}'' (enclosed in ''{1}''), which will result in compile errors if you proceed

MoveMembersRefactoring_Move_Members=Move Members
MoveMembersRefactoring_compile_errors=Operation cannot be performed due to compile errors in ''{0}''. To perform this operation you will need to fix the errors.
MoveMembersRefactoring_deleteMembers= delete members
MoveMembersRefactoring_addMembers= add members
MoveMembersRefactoring_referenceUpdate= update reference to moved member
MoveMembersRefactoring_static_declaration=Static members can be declared only in top level or static types.
MoveMembersRefactoring_check_availability=Check availability of members after move
MoveMembersRefactoring_multi_var_fields=Only field declarations with single variable declaration fragments can be moved.
MoveMembersRefactoring_only_public_static=Only 'public static' types and 'public static final' fields with variable initializers can be moved to an interface.
MoveMembersRefactoring_Object=Move is not allowed on members declared in 'java.lang.Object'.
MoveMembersRefactoring_binary=Pull up is not allowed on members of binary types.
MoveMembersRefactoring_read_only=Pull up is not allowed on members of read-only types.
MoveMembersRefactoring_move_members=Move members
MoveMembersRefactoring_not_found=Destination type ''{0}'' cannot be found
MoveMembersRefactoring_same=Destination and source types are the same (''{0}'')
MoveMembersRefactoring_inside=Destination type ''{1}'' is inside moved member''{0}''.
MoveMembersRefactoring_not_exist=Destination type ''{0}'' does not exist
MoveMembersRefactoring_dest_binary=Destination type ''{0}'' is binary
MoveMembersRefactoring_native=Moved method ''{0}'' is native. You will need to update native libraries.
MoveMembersRefactoring_moved_field=In ''{2}'', moved field ''{0}'' will not be visible from ''{1}''
MoveMembersRefactoring_accessed_field=Accessed field ''{0}'' will not be visible from ''{1}''
MoveMembersRefactoring_moved_method=In ''{2}'', moved method ''{0}'' will not be visible from ''{2}''
MoveMembersRefactoring_accessed_method=Accessed method ''{0}'' will not be visible from ''{1}''
MoveMembersRefactoring_moved_type=In ''{2}'', moved type ''{0}'' will not be visible from ''{2}''
MoveMembersRefactoring_accessed_type=Accessed type ''{0}'' will not be visible from ''{1}''
MoveMembersRefactoring_creating=Checking preconditions...
MoveMembersRefactoring_checking=Checking preconditions...
MoveRefactoring_scanning_qualified_names=Scanning for qualified names in non-Java files...

QualifiedNameFinder_update_name=Update fully qualified name

#######################################
# org.eclipse.jdt.internal.core.refactoring.surround
#######################################

SurroundWithTryCatchRefactoring_name=Surround with try/catch Block
SurroundWithTryCatchAnalyzer_doesNotCover=Selection does not cover a set of statements. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
SurroundWithTryCatchAnalyzer_doesNotContain=Selection does not contain statements from a method body or static initializer.
SurroundWithTryCatchAnalyzer_noUncaughtExceptions=No uncaught exceptions are thrown by the selected code.
SurroundWithTryCatchAnalyzer_onlyStatements=Only statements can be surrounded with try/catch blocks.
SurroundWithTryCatchAnalyzer_cannotHandleSuper=Cannot surround a super constructor call.
SurroundWithTryCatchAnalyzer_cannotHandleThis=Cannot surround a constructor invocation.
SurroundWithTryCatchAnalyzer_compile_errors=The selected code cannot be analyzed because of compilation errors. To perform this operation you will need to fix the errors.

#######################################
# org.eclipse.jdt.internal.core.refactoring.util
#######################################

CommentAnalyzer_internal_error=Internal error during precondition checking.
CommentAnalyzer_ends_inside_comment=Selection ends inside a comment.
CommentAnalyzer_starts_inside_comment=Selection begins inside a comment.

StatementAnalyzer_doesNotCover= The selection does not cover a set of statements or an expression. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
StatementAnalyzer_beginning_of_selection=The beginning of the selection contains characters that do not belong to a statement.
StatementAnalyzer_end_of_selection=The end of the selection contains characters that do not belong to a statement.
StatementAnalyzer_do_body_expression=Operation not applicable to a \'do\' statement's body and expression.
StatementAnalyzer_for_initializer_expression=Operation not applicable to a \'for\' statement's initializer and expression part.
StatementAnalyzer_for_expression_updater=Operation not applicable to a \'for\' statement's expression and updater part.
StatementAnalyzer_for_updater_body=Operation not applicable to a \'for\' statement's updater and body part.
StatementAnalyzer_catch_argument=Operation is not applicable to a catch block's argument declaration.
StatementAnalyzer_while_expression_body=Operation not applicable to a while statement's expression and body.
StatementAnalyzer_try_statement=Selection must either cover whole try statement or parts of try, catch, or finally block.
StatementAnalyzer_switch_statement=Selection must either cover whole switch statement or parts of a single case block.
StatementAnalyzer_synchronized_statement=Selection must either cover whole synchronized statement or parts of the synchronized block.

CodeAnalyzer_array_initializer=Operation not applicable to an array initializer.
JavaElementUtil_initializer=initializer

#######################################
# other
#######################################
CopyResourceString_copy=Copy resource ''{0}'' to ''{1}''

RenameAnalyzeUtil_shadows=Problem in ''{0}''. Another name will shadow access to the renamed element
RenameAnalyzeUtil_reference_shadowed=Problem in ''{0}''. The reference to ''{1}'' will be shadowed by a renamed declaration
CopyRefactoring_update_ref=Update type reference
CopyRefactoring_searching=Searching
CodeRefactoringUtil_error_message=The body of the method ''{0}'' cannot be analyzed because of compilation errors in that method. To perform the operation you will need to fix the errors.
InlineTemRefactoring_error_message_nulLiteralsCannotBeInlined=Null literals cannot be inlined
InlineTemRefactoring_error_message_fieldsCannotBeInlined=Cannot inline fields
RenameMethodRefactoring_taskName_checkingPreconditions=Checking preconditions...
RenameMethodRefactoring_taskName_searchingForReferences=Searching for references...

HierarchyRefactoring_initializer=initializer
HierarchyRefactoring_add_member=Add member declaration
HierarchyRefactoring_remove_member=Remove member declaration
HierarchyRefactoring_does_not_exist=One of the elements does not exist in the saved version of the file
HierarchyRefactoring_gets_instantiated=Class ''{0}'' cannot be made abstract because it is instantiated
HierarchyRefactoring_interface_members=Members in interfaces cannot be moved.
HierarchyRefactoring_annotation_members=Members in annotations cannot be moved.
HierarchyRefactoring_enum_members=Members in enumerations cannot be moved.
HierarchyRefactoring_members_of_binary=Moving of members declared in binary types is not supported
HierarchyRefactoring_members_of_read_only=Moving of members declared in read-only types is not supported

PushDownRefactoring_name=Push Down
PushDownRefactoring_no_subclasses=Push Down is not allowed on type ''{0}'', since it does not have subclasses to which members could be pushed down.
PushDownRefactoring_calculating_required=Calculating required members...
PushDownRefactoring_change_name=Push down
PushDownRefactoring_referenced=Pushed down member ''{0}'' is referenced by ''{1}''
PushDownRefactoring_check_references=Checking referenced elements...
PushDownRefactoring_type_not_accessible=Type ''{0}'' referenced in one of the pushed elements is not accessible from type ''{1}''
PushDownRefactoring_field_not_accessible=Field ''{0}'' referenced in one of the pushed elements is not accessible from type ''{1}''
PushDownRefactoring_method_not_accessible=Method ''{0}'' referenced in one of the pushed elements is not accessible from type ''{1}''
PushDownRefactoring_checking=Checking preconditions...

ChangeSignatureRefactoring_modify_Parameters=Change Method Signature
ChangeSignatureRefactoring_restructure_parameters=Restructure parameters
ChangeSignatureRefactoring_checking_preconditions=Checking preconditions...
ChangeSignatureRefactoring_method_deleted=The selected method has been deleted from ''{0}''.
ChangeSignatureRefactoring_native=Method ''{0}'' declared in type ''{1}'' is native. Reordering parameters will cause UnsatisfiedLinkError on runtime if you do not update your native libraries.
ChangeSignatureRefactoring_duplicate_name=Duplicate parameter name: ''{0}''.
ChangeSignatureRefactoring_return_type_contains_type_variable=The return type ''{0}'' contains the type variable ''{1}'', which may not be available in related methods.
ChangeSignatureRefactoring_method_name_not_empty=The method name cannot be empty.
ChangeSignatureRefactoring_default_value=Enter the default value for parameter ''{0}''.
ChangeSignatureRefactoring_invalid_expression=''{0}'' is not a valid expression.
ChangeSignatureRefactoring_parameter_type_contains_type_variable=The type ''{0}'' of parameter ''{1}'' contains the type variable ''{2}'', which may not be available in related methods.
ChangeSignatureRefactoring_unchanged=Method signature and return type are unchanged.
ChangeSignatureRefactoring_parameter_used=Removed parameter ''{0}'' is used in method ''{1}'' declared in type ''{2}''.
ChangeSignatureRefactoring_anonymous_subclass=anonymous subclass of ''{0}''
ChangeSignatureRefactoring_non_virtual=Changing visibility to \'private\' will make this method non-virtual, which may affect the program\'s behavior.
ChangeSignatureRefactoring_already_has=Method ''{0}'' already has a parameter named ''{1}''.
ChangeSignatureRefactoring_preview=Preparing preview
ChangeSignatureRefactoring_constructor_name=The method should not have the same name as the declaring type.
ChangeSignatureRefactoring_no_exception_binding=Cannot resolve the type binding of a thrown exception. Compilation errors must be fixed before this refactoring can be performed.
ChangeSignatureRefactoring_param_name_not_empty=Enter the name for parameter {0}.
ChangeSignatureRefactoring_change_signature=Change signature
ChangeSignatureRefactoring_update_reference=Update reference
ChangeSignatureRefactoring_update_parameter_references=Update parameter references
ChangeSignatureRefactoring_update_javadoc_reference=Update javadoc reference
ChangeSignatureRefactoring_add_super_call=Add super constructor call
ChangeSignatureRefactoring_add_constructor=Add constructor
ChangeSignatureRefactoring_cannot_convert_vararg=The variable arity ellipsis (...) cannot be removed from the last parameter ''{0}''.
ChangeSignatureRefactoring_vararg_must_be_last=The variable arity parameter ''{0}'' cannot be followed by another parameter.
ChangeSignatureRefactoring_ripple_cannot_convert_vararg=The last parameter ''{0}'' must end with an ellipsis (...), since it is a variable arity parameter in type ''{1}''.

TypeContextChecker_couldNotResolveType=Could not resolve type ''{0}''.
TypeContextChecker_ambiguous=Parameter type name ''{0}'' is ambiguous. There are {1} types with that name.
TypeContextChecker_not_unique=Parameter type name ''{0}'' cannot be uniquely resolved or is not a valid type name.
TypeContextChecker_parameter_type=Enter the type for parameter ''{0}''.
TypeContextChecker_no_vararg_below_50=''{0}'' is not a valid parameter type; variable arity parameters are only supported if the source level is 5.0.
TypeContextChecker_invalid_type_name=''{0}'' is not a valid parameter type.
TypeContextChecker_invalid_type_syntax=''{0}'' is not a valid parameter type: {1}.
TypeContextChecker_return_type_not_empty=The return type cannot be empty.
TypeContextChecker_invalid_return_type=''{0}'' is not a valid return type.
TypeContextChecker_invalid_return_type_syntax=''{0}'' is not a valid return type: {1}.

MoveInnerToTopRefactoring_names_start_lowercase=This name is discouraged. According to convention, names of instance fields and local variables start with a lowercase letter.
MoveInnerToTopRefactoring_already_declared=A field named ''{0}'' is already declared in type ''{1}''
MoveInnerToTopRefactoring_deleted=The selected type has been deleted from ''{0}''
MoveInnerToTopRefactoring_compilation_Unit_exists=A compilation unit named ''{0}'' already exists in package ''{1}''
MoveInnerToTopRefactoring_name_used=Name ''{0}'' is used as a parameter name in one of the constructors of type ''{1}''
MoveInnerToTopRefactoring_name=Move Member Type to New File
MoveInnerToTopRefactoring_creating_change=Creating change
MoveInnerToTopRefactoring_update_type_reference=Update type reference
MoveInnerToTopRefactoring_update_constructor_reference=Update constructor occurrence
MoveInnerToTopRefactoring_move_to_Top=Move Member Type to New File
MoveInnerToTopRefactoring_change_visibility=Change visibility to default
MoveInnerToTopRefactoring_change_visibility_type_warning=The visibility of type ''{0}'' will be changed to default.
MoveInnerToTopRefactoring_change_visibility_method_warning=The visibility of method ''{0}'' will be changed to default.
MoveInnerToTopRefactoring_change_visibility_field_warning=The visibility of field ''{0}'' will be changed to default.
MoveInnerToTopRefactoring_change_qualifier=Qualify class name
MoveInnerToTopRefactoring_type_exists=Type named ''{0}'' already exists in package ''{1}''

UseSupertypeWherePossibleRefactoring_name=Use Supertype Where Possible
UseSuperTypeProcessor_name=Replace Type ''{0}'' by ''{1}''
UseSuperTypeProcessor_internal_error=Internal error during precondition checking. Consult log for detailed error description.
UseSuperTypeProcessor_creating=Checking preconditions...
UseSuperTypeProcessor_checking=Checking preconditions...

SuperTypeRefactoringProcessor_creating=Checking preconditions...
SuperTypeRefactoringProcessor_update_type_occurrence=Update type occurrence

MoveInstanceMethodRefactoring_name=Move Method
MoveInstanceMethodProcessor_name= Move Method ''{0}''
MoveInstanceMethodProcessor_no_static_methods=This refactoring cannot be used to move static methods.
MoveInstanceMethodProcessor_single_implementation=This refactoring cannot be used to move abstract methods.
MoveInstanceMethodProcessor_no_native_methods=This refactoring cannot be used to move native methods.
MoveInstanceMethodProcessor_no_synchronized_methods=This refactoring cannot be used to move synchronized methods.
MoveInstanceMethodProcessor_no_constructors=This refactoring cannot be used to move a constructor.
MoveInstanceMethodProcessor_uses_super=The method cannot be moved, since it uses the 'super' keyword.
MoveInstanceMethodProcessor_refers_enclosing_instances=The method cannot be moved, since it has references to enclosing instances.
MoveInstanceMethodProcessor_potentially_recursive=This refactoring cannot be used to move potentially recursive methods.
MoveInstanceMethodProcessor_cannot_be_moved=This method cannot be moved, since no possible targets have been found. An instance method can be moved to source classes that are used as types of its parameters or types of fields declared in the same class as the method.
MoveInstanceMethodProcessor_no_type_variables=This method cannot be moved, since it contains references to non-local type parameters.
MoveInstanceMethodProcessor_no_generic_targets=This method cannot be moved to the specified target, since the target is a generic entity.
MoveInstanceMethodProcessor_no_binary=Cannot move methods to binary types.
MoveInstanceMethodProcessor_no_interface=This refactoring cannot be used to move interface methods.
MoveInstanceMethodProcessor_no_annotation=This refactoring cannot be used to move annotation methods.
MoveInstanceMethodProcessor_this_reference=A reference to 'this' has been found
MoveInstanceMethodProcessor_no_resolved_target=The target of the method could not be resolved.
MoveInstanceMethodProcessor_no_null_argument=The method invocation ''{0}'' cannot be updated, since it uses ''null'' as argument.
MoveInstanceMethodProcessor_target_name_already_used=The name of the target conflicts with the method parameter ''{0}''.
MoveInstanceMethodProcessor_replace_body_with_delegation=Create delegator method
MoveInstanceMethodProcessor_remove_original_method=Remove method declaration
MoveInstanceMethodProcessor_inline_method_invocation=Update method invocation
MoveInstanceMethodProcessor_deprecate_delegator_method=Deprecate delegator method
MoveInstanceMethodProcessor_deprecate_delegator_message=Use {0} instead
MoveInstanceMethodProcessor_add_moved_method=Add method declaration
MoveInstanceMethodProcessor_inline_binary_project=The method invocations to the moved method in project ''{0}'' cannot be updated, since the project is binary.
MoveInstanceMethodProcessor_inline_binary_resource=The method invocations to the moved method in resource ''{0}'' cannot be updated.
MoveInstanceMethodProcessor_javadoc_binary_project=Javadoc references to the moved method in project ''{0}'' cannot be updated, since the project is binary.
MoveInstanceMethodProcessor_javadoc_binary_resource=Javadoc references to the moved method in resource ''{0}'' cannot be updated.
MoveInstanceMethodProcessor_inline_inaccurate=A method invocation to the original method in ''{0}'' could not be fully resolved.
MoveInstanceMethodProcessor_inline_overridden=The method invocations to ''{0}'' cannot be updated, since the original method is used polymorphically.
MoveInstanceMethodProcessor_method_already_exists=A method with name ''{0}'' already exists in the target type ''{1}''.
MoveInstanceMethodProcessor_method_type_clash=The method cannot have the same name as its target type ''{0}''.
MoveInstanceMethodProcessor_creating=Checking preconditions...
MoveInstanceMethodProcessor_checking=Checking preconditions...

ExtractInterfaceRefactoring_name=Extract Interface
ExtractInterfaceProcessor_name= Extract Interface from ''{0}''
ExtractInterfaceProcessor_no_binary=Cannot extract interfaces from binary types.
ExtractInterfaceProcessor_no_annotation=Cannot extract interfaces from annotations.
ExtractInterfaceProcessor_no_anonymous=Cannot extract interfaces from anonymous types.
ExtractInterfaceProcessor_existing_type=A type named ''{0}'' already exists in package ''{1}''
ExtractInterfaceProcessor_existing_default_type=A type named ''{0}'' already exists in the default package
ExtractInterfaceProcessor_existing_compilation_unit=A compilation unit named ''{0}'' already exists in package ''{1}''
ExtractInterfaceProcessor_internal_error=Internal error during precondition checking. Consult log for detailed error description.
ExtractInterfaceProcessor_creating=Checking preconditions...
ExtractInterfaceProcessor_checking=Checking preconditions...

#Begin - Do not remove
MemberVisibilityAdjustor_binary_outgoing_project=The elements in project ''{0}'' referenced from ''{1}'' cannot be updated, since the project is binary.
MemberVisibilityAdjustor_binary_outgoing_resource=The elements in resource ''{0}'' referenced from ''{1}'' cannot be updated.
MemberVisibilityAdjustor_change_visibility_type_warning=The visibility of type ''{0}'' will be changed to {1}.
MemberVisibilityAdjustor_change_visibility_method_warning=The visibility of method ''{0}'' will be changed to {1}.
MemberVisibilityAdjustor_change_visibility_field_warning=The visibility of field ''{0}'' will be changed to {1}.
#End - Do not remove
MemberVisibilityAdjustor_change_visibility_default=default
MemberVisibilityAdjustor_change_visibility_public=public
MemberVisibilityAdjustor_change_visibility_protected=protected
MemberVisibilityAdjustor_change_visibility_private=private
MemberVisibilityAdjustor_change_visibility=Change visibility to {0}

MemberVisibilityAdjustor_adjusting=Adjusting visibility...
MemberVisibilityAdjustor_checking=Checking visibility...

CopyPackageFragmentRootChange_copy=Copy Package Fragment Root ''{0}'' to project ''{1}''

DeletePackageFragmentRootChange_delete=Delete package fragment root ''{0}''

MovePackageFragmentRootChange_move=Move Package Fragment Root ''{0}'' to project ''{1}''

PromoteTempToFieldRefactoring_name=Promote Local Variable to Field
PromoteTempToFieldRefactoring_select_declaration=Select a declaration or a reference to a local variable.
PromoteTempToFieldRefactoring_only_declared_in_methods=Only local variables declared in methods can be converted to fields.
PromoteTempToFieldRefactoring_method_parameters=Cannot convert method parameters to fields.
PromoteTempToFieldRefactoring_exceptions=Cannot convert exceptions declared in catch clauses to fields.
PromoteTempToFieldRefactoring_uses_types_declared_locally=Cannot promote this local variable to a field because it uses types or variables declared locally in the method.
PromoteTempToFieldRefactoring_cannot_promote=Cannot promote this local variable to a field.
PromoteTempToFieldRefactoring_uses_type_declared_locally=Cannot promote this local variable to a field because it uses a type declared locally in the method.
PromoteTempToFieldRefactoring_Name_conflict=Name conflict with name ''{0}'' used in ''{1}''
PromoteTempToFieldRefactoring_Name_conflict_with_field=Name conflict with existing field
PromoteTempToFieldRefactoring_editName=Promote local variable to field

ConvertAnonymousToNestedRefactoring_name=Convert Anonymous to Inner
ConvertAnonymousToNestedRefactoring_place_caret=Place the caret inside an anonymous inner class.
ConvertAnonymousToNestedRefactoring_type_exists=Nested type with that name already exists.
ConvertAnonymousToNestedRefactoring_another_name=Choose another name.
ConvertAnonymousToNestedRefactoring_name_hides=Class name hides an enclosing type name.
ConvertAnonymousToNestedRefactoring_compile_errors=This refactoring cannot be performed due to compile errors in the compilation unit. To perform this operation you will need to fix the errors.
ConvertAnonymousToNestedRefactoring_anonymous_field_access=Class accesses fields in enclosing anonymous type. The refactored code will not compile.
ConvertAnonymousToNestedRefactoring_edit_name=Convert anonymous inner class to a nested class
ConvertAnonymousToNestedRefactoring_extends_local_class=Cannot convert this anonymous class to a nested class since it extends a local class.

InlineConstantRefactoring_members_declared_in_anonymous=Cannot inline since the initializer to be inlined refers to members declared in an anonymous class scope (not supported).
InlineConstantRefactoring_Inline=Inline Constant
InlineConstantRefactoring_syntax_errors=This file contains syntax errors. To perform this operation you will need to fix the errors.
InlineConstantRefactoring_local_anonymous_unsupported=Inlining of constants defined in local or anonymous classes is not supported.
InlineConstantRefactoring_static_final_field=A static final field must be selected.
InlineConstantRefactoring_blank_finals=Inline Constant cannot inline blank finals.
InlineConstantRefactoring_binary_file=Cannot inline this constant, since it is declared in a binary file.
InlineConstantRefactoring_preview=Generating preview ...
InlineConstantRefactoring_inline=Inline Constant
InlineConstantRefactoring_remove_declaration=Remove constant declaration
InlineConstantRefactoring_name=Inline Constant
InlineConstantRefactoring_source_code_unavailable=References in ''{0}'' cannot be inlined since source code is not available

DeleteFileChange_1=Delete file ''{0}''

DeleteFolderChange_0=Delete folder ''{0}''

DeleteSourceManipulationChange_0=Delete ''{0}''
DeleteSourceManipulationChange_1=(default package)

JavaCopyProcessor_changeName=Copy
JavaCopyProcessor_processorName=Java Copy Processor

MoveRefactoring_0=Move

OverwriteHelper_0=Confirm overwriting
OverwriteHelper_1=''{0}'' exists in the selected destination. Do you want to overwrite?

OverwriteHelper_2=Element exists in Destination
OverwriteHelper_3=The element ''{0}'' exists in the selected destination. You can either skip the element or cancel the whole operation.

ReadOnlyResourceFinder_0=Confirm Delete of Read-Only Elements
ReadOnlyResourceFinder_1=The selected elements contain read-only resources. Do you still want to delete them?
ReadOnlyResourceFinder_2=Confirm Move of Read-Only Elements
ReadOnlyResourceFinder_3=The selected elements contain read-only resources. Do you still want to move them?

MoveInnerToTopRefactoring_creating_preview=Creating preview
MoveInnerToTopRefactoring_change_label=Move member type to new file

# ---- Reorg
ReorgPolicy_copy=Copy resource modifications
ReorgPolicy_copy_source_folder=Copy source folder modifications
ReorgPolicy_copy_package=Copy package modifications
ReorgPolicy_move_source_folder=Move source folder modifications
ReorgPolicy_move_package=Move package modifications
ReorgPolicy_move=Move resource modifications
ReorgPolicy_move_members=Move member modifications
ReorgPolicyFactory_doesnotexist0=The selected element cannot be the destination of this operation
ReorgPolicyFactory_readonly=The selected destination is read-only
ReorgPolicyFactory_structure=The structure of the selected destination is not known
ReorgPolicyFactory_inconsistent=The selected destination is not consistent with its underlying resource or buffer
ReorgPolicyFactory_archive=The selected destination is an archive
ReorgPolicyFactory_external=The selected destination is external to the workbench
ReorgPolicyFactory_phantom=The selected destination does not exist or is a phantom resource
ReorgPolicyFactory_inaccessible=The selected destination is not accessible
ReorgPolicyFactory_not_this_resource=The selected resource cannot be used as a destination
ReorgPolicyFactory_linked=Linked resources can only be copied to projects
ReorgPolicyFactory_no_resource=A resource cannot be the destination for the selected elements.
ReorgPolicyFactory_copy=Copy
ReorgPolicyFactory_doesnotexist1=The selected element cannot be the destination for this operation
ReorgPolicyFactory_cannot_modify=The selected destination element cannot be modified
ReorgPolicyFactory_cannot=The selected element cannot be the destination for this operation
ReorgPolicyFactory_package_decl=Package declarations are not available as destinations
ReorgPolicyFactory_src2proj=Source folders can only be copied to Java projects
ReorgPolicyFactory_jmodel=The Java Model cannot be the destination of this operation
ReorgPolicyFactory_src2writable=Source folders cannot be copied to read-only elements
ReorgPolicyFactory_src2nosrc=Source folders cannot be copied or moved to projects that contain no source folders
ReorgPolicyFactory_packages=Packages can only be moved or copied to source folders or Java projects that do not have source folders
ReorgPolicyFactory_cannot1=The selected element cannot be the destination of this operation
ReorgPolicyFactory_noCopying=Copying is not available
ReorgPolicyFactory_element2parent=Elements cannot be moved to their own parents.
ReorgPolicyFactory_package2parent=A package cannot be moved to its own parent.
ReorgPolicyFactory_parent=A file or folder cannot be moved to its own parent.
ReorgPolicyFactory_noMoving=Moving is not available

ReorgUtils_0=file ''{0}''
ReorgUtils_1=folder ''{0}''
ReorgUtils_2=project ''{0}''
ReorgUtils_3=class file ''{0}''
ReorgUtils_4=file ''{0}''
ReorgUtils_5=field ''{0}''
ReorgUtils_6=the import container
ReorgUtils_7=import declaration ''{0}''
ReorgUtils_8=the initializer
ReorgUtils_9=Java project ''{0}''
ReorgUtils_10=constructor ''{0}''
ReorgUtils_11=method ''{0}''
ReorgUtils_12=package declaration ''{0}''
ReorgUtils_13=the default package
ReorgUtils_14=package ''{0}''
ReorgUtils_15=source folder ''{0}''
ReorgUtils_16=class folder ''{0}''
ReorgUtils_17=package fragment root ''{0}''
ReorgUtils_18=type ''{0}''
ReorgUtils_19=new {0}() '{'...}
ReorgUtils_20=anonymous type ''{0}''
DeleteChangeCreator_1=Delete elements
DeleteRefactoring_1=Analyzing...
DeleteRefactoring_2=Confirm Referenced Archive Delete
DeleteRefactoring_3=Archive file ''{0}'' is referenced by the following project(s). Do you still want to delete it?
DeleteRefactoring_4=Confirm Folder Delete
DeleteRefactoring_5=Folder ''{0}'' contains a Java source folder. Deleting it will delete the source folder as well. Do you still wish to delete it?
DeleteRefactoring_7=Delete
DeleteRefactoring_8=Confirm Delete of Getters/Setters
DeleteRefactoring_9=Do you also want to delete getter/setter methods for field ''{0}''?
MoveStaticMemberAnalyzer_nonStatic=Replacing non-static access to static member with static access

#
# Introduce Factory
IntroduceFactory_name=Introduce Factory
IntroduceFactory_checkingActivation=Checking activation of IntroduceFactory
IntroduceFactory_syntaxError=Syntax errors in compilation unit; unable to proceed.
IntroduceFactory_checking_preconditions=Checking preconditions for Introduce Factory...
IntroduceFactory_examiningSelection=Examining selection...
IntroduceFactory_notAConstructorInvocation=Selected entity is not a constructor invocation or definition.
#
IntroduceFactory_noASTNodeForConstructorSearchHit=Cannot find AST node for constructor search hit @ [''{0}'', ''{1}'']: <''{2}''> in compilation unit ''{3}''
IntroduceFactory_unexpectedInitializerNodeType=Unexpected AST node type for initializer when searching for constructor call: \'''{0}''\' in compilation unit ''{1}''
IntroduceFactory_noConstructorCallNodeInsideFoundVarbleDecl=Could not find AST node for constructor call inside ''{0}''
IntroduceFactory_unexpectedASTNodeTypeForConstructorSearchHit=Unexpected AST node type for constructor search hit: ''{0}'' in compilation unit ''{1}''
IntroduceFactory_noBindingForSelectedConstructor=Could not resolve binding of selected constructor; possibly a reference to an unknown type.
#
IntroduceFactory_addFactoryMethod=Add factory method
IntroduceFactory_replaceCalls=Replace constructor calls with calls to factory method
IntroduceFactory_protectConstructor=Protect constructor
#
IntroduceFactory_unsupportedNestedTypes=Introduce Factory does not support constructors on nested types.
IntroduceFactory_duplicateMethodName=Duplicate method name:
IntroduceFactory_createChanges=Creating changes for IntroduceFactory
IntroduceFactory_topLevelChangeLabel=Changes to introduce a factory for
IntroduceFactory_constructorInBinaryClass=Introduce Factory is not supported when the constructor is in a binary class.
IntroduceFactory_unableToResolveConstructorBinding=Unable to resolve call target; check for possible compilation errors
IntroduceFactory_callSitesInBinaryClass=Constructor call sites in binary classes cannot be replaced by factory method calls.
IntroduceFactory_noSuchClass=Class ''{0}'' does not exist.
IntroduceFactory_cantPutFactoryMethodOnInterface=Cannot place factory method on an interface
IntroduceFactory_cantPutFactoryMethodOnAnnotation=Cannot place factory method on an annotation
IntroduceFactory_cantCheckForInterface=Unable to determine whether factory type is an interface
IntroduceFactory_cantPutFactoryInBinaryClass=Cannot place factory inside binary class
IntroduceFactory_constructorInEnum=Introduce Factory is not supported for constructors of enumerated types.

#--- Generalize Type
ChangeTypeRefactoring_Generalize_Type=Generalize Type
ChangeTypeRefactoring_checking_preconditions=Checking preconditions...
ChangeTypeRefactoring_changes=Computing changes
ChangeTypeRefactoring_name=Generalize Type
ChangeTypeRefactoring_cantDoIt=Type of selected declaration cannot be changed
ChangeTypeRefactoring_notSupportedOnNodeType=Generalize Type is only supported on declarations of variables, parameters, and fields, and on method return types.
ChangeTypeRefactoring_notSupportedOnBinary=Generalize Type is not allowed on return types and parameters of methods that override binary methods.
ChangeTypeRefactoring_invalidSelection=Invalid selection for Generalize Type.
ChangeTypeRefactoring_multiDeclarationsNotSupported=Multi-declarations currently not handled.
ChangeTypeRefactoring_noMatchingConstraintVariable=No constraint variable matches the selected ASTNode.
ChangeTypeRefactoring_unhandledSearchException=exception occurred during search:
ChangeTypeRefactoring_failedToSelectType=failed to select type:
ChangeTypeMessages_CreateChangesForChangeType=Creating changes for Generalize Type...
ChangeTypeRefactoring_javaLangObject=java.lang.Object
ChangeTypeRefactoring_arraysNotSupported=Generalize Type is not supported on array types.
ChangeTypeRefactoring_localTypesNotSupported=Generalize Type is not supported on local types.
ChangeTypeRefactoring_primitivesNotSupported=Generalize Type is not supported on primitive types.
ChangeTypeRefactoring_typeChange=change declared type from
ChangeTypeRefactoring_allChanges=Generalize Type
ChangeTypeRefactoring_to=\ to
ChangeTypeRefactoring_analyzingMessage=Analyzing...
ChangeTypeRefactoring_no_method=Selection cannot be mapped to a method
ChangeTypeRefactoring_no_filed=Selection cannot be mapped to a field
ChangeTypeRefactoring_insideLocalTypesNotSupported=Generalize Type is currently not supported inside local types.
ChangeTypeRefactoring_typeParametersNotSupported=Generalize Type is not supported on type parameters.
ChangeTypeRefactoring_enumsNotSupported=Generalize Type is not supported on enumerated types.

#--- Infer Type Arguments
InferTypeArgumentsRefactoring_name=Infer Type Arguments
InferTypeArgumentsRefactoring_not50=Project ''{0}'' cannot be processed since its compiler source level is below 5.0.
InferTypeArgumentsRefactoring_calculating_dependencies=Calculating dependencies...
InferTypeArgumentsRefactoring_building=Building constraints system...
InferTypeArgumentsRefactoring_solving=Solving constraints...
InferTypeArgumentsRefactoring_creatingChanges=Creating changes...
InferTypeArgumentsRefactoring_internal_error=Internal error while infering type arguments in ''{0}''.
InferTypeArgumentsRefactoring_addTypeArguments=Add type arguments
InferTypeArgumentsRefactoring_removeCast=Remove cast
InferTypeArgumentsRefactoring_not50Library=Project ''{0}'' cannot be processed since its JRE System Library version is below 5.0.
InferTypeArgumentsRefactoring_error_skipped=An unexpected error happened while processing ''{0}''. The rest of this compilation unit has been skipped.
InferTypeArgumentsRefactoring_error_in_cu_skipped=Compile errors found in ''{0}''. The compilation unit has been skipped.
QualifiedNameSearchResult_change_name= Textual qualified name modifications
ASTData_update_imports=Update imports
JavaDeleteProcessor_unsaved_changes= File ''{0}'' has unsaved changes.
