ticket_id,issue_id,resolved,description,summary,created,commit_info_loc
Lang-419,419,5/11/08 5:18,"In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower.
But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too...
Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException

The fix is to adjust lower to the length of the string",WordUtils.abbreviate bug when lower is greater than str.length,3/26/08 17:05,
Lang-393,393,1/13/08 7:00,"When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal.",EqualsBuilder don't compare BigDecimals correctly,1/3/08 13:46,
Lang-380,380,11/29/07 16:34,Summary pretty much says it all.,infinite loop in Fraction.reduce when numerator == 0,11/29/07 16:24,
Lang-365,365,10/27/07 5:07,"The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test:
assertEquals(false, BooleanUtils.toBoolean(""tru""));
The end of case 3 should return false.
Patch to follow for source and unit test.",BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException,10/26/07 18:58,
Lang-346,346,8/9/07 0:25,"Get unexpected output for rounding by minutes or seconds.
public void testRound()
{
Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone(""GMT""));
testCalendar.set(2007, 6, 2, 8, 9, 50);
Date date = testCalendar.getTime();
System.out.println(""Before round() "" + date);
System.out.println(""After round() "" + DateUtils.round(date, Calendar.MINUTE));
}

--2.1 produces
Before round() Mon Jul 02 03:09:50 CDT 2007
After round() Mon Jul 02 03:10:00 CDT 2007 – this is what I would expect

--2.2 and 2.3 produces
Before round() Mon Jul 02 03:09:50 CDT 2007
After round() Mon Jul 02 03:01:00 CDT 2007 – this appears to be wrong",Dates.round() behaves incorrectly for minutes and seconds,7/6/07 20:06,
Lang-328,328,5/1/07 23:50,"LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX

This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale(""fr"", """", ""POSIX"").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code.

Commons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.",LocaleUtils.toLocale() rejects strings with only language+variant,4/16/07 23:11,
Lang-315,315,2/6/07 22:49,"In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:

StopWatch sw = new StopWatch();

sw.start();
Thread.sleep(1000);
sw.suspend();
// Time 1 (ok)
System.out.println(sw.getTime());

Thread.sleep(2000);
// Time 1 (again, ok)
System.out.println(sw.getTime());

sw.resume();
Thread.sleep(3000);
sw.suspend();
// Time 2 (ok)
System.out.println(sw.getTime());

Thread.sleep(4000);
// Time 2 (again, ok)
System.out.println(sw.getTime());

Thread.sleep(5000);
sw.stop();
// Time 2 (should be, but is Time 3 => NOT ok)
System.out.println(sw.getTime());

suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?","StopWatch: suspend() acts as split(), if followed by stop()",2/6/07 13:52,
Lang-300,300,12/19/06,"NumberUtils.createNumber throws a NumberFormatException when parsing ""1l"", ""2l"" .. etc...
It works fine if you try to parse ""01l"" or ""02l"". The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for ""1l""",NumberUtils.createNumber throws NumberFormatException for one digit long,12/19/06 17:47,
Lang-281,281,10/7/06 0:23,"DurationFormatUtils returns wrong result. oddly, it is only when Date is set to Dec 31, 2005
The following code will result in a String of -2 which is way off.
I've tested against 2.1 and 2.2.
Calendar cal = Calendar.getInstance();
cal.set(Calendar.MONTH, Calendar.DECEMBER);
cal.set(Calendar.DAY_OF_MONTH, 31);
cal.set(Calendar.YEAR, 2005);
cal.set(Calendar.HOUR_OF_DAY, 0);
cal.set(Calendar.MINUTE, 0);
cal.set(Calendar.SECOND, 0);
cal.set(Calendar.MILLISECOND, 0);
String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), ""MM"");
System.out.println(result);",DurationFormatUtils returns wrong result,10/5/06 16:51,
Lang-259,259,8/18/06 22:21,"int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)
is not typesafe - if the int-values are the same, it will return ""0"" even for two totally different sub-classes of ValuedEnum",ValuedEnum.compareTo(Object other) not typesafe - it easily could be…,5/22/06 21:10,